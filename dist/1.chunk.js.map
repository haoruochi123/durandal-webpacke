{"version":3,"sources":["../(webpack)/buildin/module.js",".././app/viewModels/router/index.js",".././app/viewModels/router/routes.js",".././app/viewModels/router/viewModels/how/how.js",".././app/viewModels/router/index.html",".././app/viewModels/router/viewModels/how/how.html"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA,iBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0E,8CAAA;AACA;AACA,K;0EAAI;AACJ,IAAG;AACH;AACA;AACA;;;;;;;;ACvBA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;;;;;;;;ACPA,k4BAAi4B,mBAAmB,mCAAmC,aAAa,uGAAuG,yBAAyB,uC;;;;;;;ACApkC,inB","file":"1.chunk.js","sourcesContent":["module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 22\n// module chunks = 1","var router = require('plugins/router');\nvar ViewModel = require('viewModels/class');\n\nvar Index = new ViewModel({\n\tview: require('./index.html')\n});\n\nIndex.router  = router.createChildRouter()\n\t.makeRelative({ fromParent: true })\n\t.map(\n\t\trequire('./routes')\n\t)\n\t.buildNavigationModel();\n\nmodule.exports = Index;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/viewModels/router/index.js\n// module id = 34\n// module chunks = 1","module.exports = [\n\t{\n\t\troute: '', \n\t\ttitle: 'What?',\n\t\tmoduleId: function() {\n\t\t\treturn require('./viewModels/how/how');\n\t\t},\n\t\tnav: true\n\t},\n\n\t// We can nest async routes, too, allowing us to conviniently\n\t// separate out various parts of our application into distinct,\n\t// async loaded parts. Beautiful!\n\t{\n\t\troute: 'nested', \n\t\ttitle: 'One other thing...',\n\t\tmoduleId: function(cb) {\n\t\t\trequire(['./viewModels/nested/nested'], function(module) {\n\t\t\t\tcb(null, module);\n\t\t\t});\n\t\t},\n\t\tnav: true\n\t}\n];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/viewModels/router/routes.js\n// module id = 35\n// module chunks = 1","var router = require('plugins/router');\nvar ViewModel = require('viewModels/class');\n\nvar How = new ViewModel({\n\tview: require('./how.html')\n});\n\nmodule.exports = How;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/viewModels/router/viewModels/how/how.js\n// module id = 36\n// module chunks = 1","module.exports = \"<section id=\\\"async\\\">\\n\\t<header><h3>Router</h3></header>\\n\\t<p>\\n\\t\\tWe can interface nicely with the <code>router</code> component, too. You're seeing that in action now!\\n\\t</p>\\n\\t<br />\\n\\n\\t<article>\\n\\t\\t<header><h4>How?</h4></header>\\n\\t\\t<p>\\n\\t\\t\\tTypically Durandals <code>router</code> module requires you to specify a <code>moduleId</code>\\n\\t\\t\\tfor each route.\\n\\t\\t</p>\\n\\n\\t\\t<p>\\n\\t\\t\\tTo allow Webpack to know these are actual dependencies, we instead set each\\n\\t\\t\\t<code>moduleId</code> to the actual ViewModel module instance instead, and override the core\\n\\t\\t\\tDurandal <code>composition</code> and <code>system</code> modules to handle it.\\n\\t\\t</p>\\n\\t</article>\\n\\t<br />\\n\\n\\t<article>\\n\\t\\t<header><h4>Asynchronous Routes!</h4></header>\\n\\n\\t\\t<ul class=\\\"nav nav-tabs\\\" data-bind=\\\"foreach: router.navigationModel\\\">\\n\\t\\t\\t<li data-bind=\\\"css: { active: isActive }\\\">\\n\\t\\t\\t\\t<a data-bind=\\\"attr: { href: hash }, html: title\\\"></a>\\n\\t\\t\\t</li>\\n\\t\\t</ul>\\n\\n\\t\\t<div class=\\\"container\\\" style=\\\"padding-top: 20px;\\\" data-bind=\\\"router: {}\\\"></div>\\t\\n\\t</article>\\n</section>\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/viewModels/router/index.html\n// module id = 45\n// module chunks = 1","module.exports = \"<div>\\n\\t<p>\\n\\t\\tAlong with the ability to bundle all the routes together, we can also optionally bundle specific\\n\\t\\tparts of the application together into chucks we can grab on-the-fly when the user goes to\\n\\t\\tspecific routes!\\n\\t</p>\\n\\t<p>\\n\\t\\tIn fact... <b>this very page was requested separately from the main <code>app.js</code></b>.\\n\\t\\tCheck the network tab to see this in action (look for the <code>1.chunk.js</code> file)!\\n\\t</b>\\n\\t<p>\\n\\t\\tThis is great for large apps where we don't need or want the user to download the entirety of\\n\\t\\tthe application code at once.\\n\\t</p>\\n</div>\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/viewModels/router/viewModels/how/how.html\n// module id = 46\n// module chunks = 1"],"sourceRoot":""}